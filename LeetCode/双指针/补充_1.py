# 题目： 给定两个字符串，比如 s1=acdk, s2=ckad，每次可以将 s1 中任意一个字母移到末尾，问最少移动次数使得 s1=s2。如果无法匹配，返回 -1。

# 方法思路
# 字符检查：首先检查两个字符串是否包含相同的字符且每个字符的出现次数一致。如果不一致，直接返回-1。
# 双指针法：使用两个指针分别遍历s1和s2，找到s2的最长前缀，该前缀可以作为s1的子序列。这个最长前缀的长度决定了需要移动的次数。


def min_moves_to_match(s1, s2):
    # 首先检查两个字符串是否由相同的字符组成，如果不是则无法匹配
    if sorted(s1) != sorted(s2):
        return -1
    # 在移动的过程中，我们希望保留尽可能多的顺序正确的字符，而移动那些不在正确位置的字符。
    n = len(s1)
    j = 0 # s2的指针
    for c in s1:
        if j < n and c == s2[j]:
            j += 1
    return n-j

# 测试示例
s1 = "acdk"
s2 = "ckad"
print(min_moves_to_match(s1, s2))


# 代码解释
# 字符检查：使用collections.Counter来统计两个字符串的字符频率。如果频率不一致，说明无法转换，返回-1。

# 双指针遍历：遍历s1的每个字符，同时用指针j跟踪s2的当前字符。每当s1中的字符与s2的当前字符匹配时，j递增。最终，j的值即为s2的最长前缀长度。

# 计算移动次数：总移动次数为字符串长度减去最长前缀长度，即n - j。

# 这种方法的时间复杂度是O(n)，其中n是字符串的长度，能够高效地解决问题。